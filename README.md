# ЛБ 2 Встраиваемые системы
---
Тема лабораторной работы:
## Знакомство с USB. Связь среды MATLAB Simulink с микроконтроллером STM32
### Цель работы

Обеспечить обмен данными между средой MATLAB Simulink, установленной на ПК и микроконтроллером семейства STM32. 

### Задание

В Simulink должен производиться расчет ответа произвольного звена САУ на возмущение, вносимое пользователем с помощью кнопки, подключенной к микроконтроллеру. Данные сигнала звена должны также передаваться на микроконтроллер.

### Знакомство с USB

Протокол шины USB обеспечивает обмен данными между хостом и устройством. На протокольном уровне решаются такие задачи, как обеспечение достоверности и надежности передачи, управление потоком. Весь трафик на шине USB передается посредством транзакций, в каждой транзакции возможен обмен только между хостом и адресуемым устройством (его конечной точкой). Все транзакции (обмены) с устройствами USB состоят из двух-трех пакетов, типовые последовательности пакетов в транзакциях приведены ниже. Каждая транзакция планируется и начинается по инициативе хост-контроллера, который посылает пакет-маркер транзакции (token packet). Маркер транзакции описывает тип и направление передачи, адрес выбранного устройства USB и номер конечной точки. Адресуемое маркером устройство распознает свой адрес и готовится к обмену. Источник данных, определенный маркером, передает пакет данных. На этом этапе транзакции, относящиеся к изохронным передачам, завершаются — здесь нет подтверждения приема пакетов. Для остальных типов передач работает механизм подтверждения, обеспечивающий гарантированную доставку данных. Форматы пакетов приведены ниже, типы пакетов — ниже. Во всех полях пакетов, кроме поля CRC, данные передаются младшим битом вперед (на временных диаграммах младший бит изображается слева). Пакет начинается с синхропоследовательности Sync и завершается признаком конца — EOP. Тип пакета определяется полем PID. Назначение остальных полей раскрывается далее. Длина полей Sync и EOP указана для передач на FS/LS, для высокоскоростных передач поле Sync удлинено до 32 битовых интервалов, а EOP до 8 (в пакетах SOF поле EOP имеет длину 40 бит).

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/7d05ef4a-1267-48ba-acd9-7aa48b4ff6dd)

где, а – вывод и б – ввод данных

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/5eb7a8de-17a6-475c-9598-ef36a5e2d489)

где, а – маркер, ю = пакет данных, в – пакет квитирования

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/598cb4bd-fa38-4a86-8ebb-b5e3d8e2bdf2)

Типы пакетов и их идентификаторы PID

Все принимаемые пакеты проверяются на наличие ошибок, что позволяют принятые форматы пакета и некоторые соглашения: пакет начинается с синхронизирующей последовательности, за которой следует его идентификатор PID (Packet Identificator). За идентификатором следует его инверсная копия — Check. Несовпадение двух копий считается признаком ошибки; тело пакета (все поля пакета, исключая PID и признак EOP) защищается CRCкодом: 5-битным для пакетов-маркеров, 16-битным — для пакетов данных. Несовпадение CRC с ожидаемым значением считается признаком ошибки; пакет завершается специальным сигналом EOP; если в пакете оказывается не целое число байт, он считается ошибочным. Ложный EOP, даже на границе байта, не позволит принять пакет из-за практически неизбежной в данной ситуации ошибки по CRC-контролю; на физический уровень (в шину) данные пакета передаются с использованием вставки бит (bit stuffing, после шести единичных бит вставляется нолик), что предотвращает потерю битовой синхронизации при монотонном сигнале. Прием более шести единичных бит подряд считается ошибкой (на HS — признаком конца кадра). Обнаружение любой из перечисленных ошибок в пакете заставляет приемник считать его недействительным. На пакеты, принятые с ошибкой, ни устройство, ни хост-контроллер никак не отвечают. При изохронной передаче данные недействительного пакета должны просто игнорироваться (они теряются); для остальных типов передач используются средства обеспечения надежной доставки.

SB — это интерфейс с одной информационной линией, что означает, что приём и передача информации могут проходить только поочерёдно. Два сигнальных провода физически выполненные в виде витой пары, передают один и тот же информационный сигнал, и представляют собой так называемое симметричное или балансное подключение, распространённое в связи и профессиональном звуке.
Для чего же оно нужно и как оно работает? Для начала. Чем симметричная линия отличается от несимметричной? Схема показана ниже:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/1fc75a66-8879-4ae9-b416-9f57175afa42)

В обеих роль источника сигнала играет аккумулятор BAT1, роль принимающей стороны - вольтметр BM1. Были использован в этом примере источник постоянного тока, т.к. цифровой сигнал в USB кабеле — это, тоже, постоянные уровни, которые с течением времени сменяют друг друга. Различие схем, на первых взгляд, несущественно, однако, если приглядеться, можно заметить, что в симметричной схеме минусовая линия подключена к оплётке и заземлена, то есть оплётка, по сути, является одним из проводников кабеля.

Если кабели оказались в зоне действия помехи. Провода кабелей окажутся под действием магнитного поля, в результате чего в них возникает явление электромагнитной индукции, то есть появится ЭДС, которая внесёт искажения в полезный сигнал.

Описанное явление называется помехой. Если рассуждать о сути протекающих в кабеле физических процессов, можно сказать, что кабель в этой ситуации ведёт себя подобно обмотке трансформатора, которая, под воздействием магнитного поля сердечника, также вырабатывает ЭДС. А значит для того, чтобы смоделировать ситуацию воздействия помехи на кабель, достаточно заменить его провода трансформаторами.

Полезный сигнал, обычно при помощи инвертора, транслируется в противофазе – плюс аккумулятора, минус аккумулятора. Помеха – хоть емкостная, хоть электромагнитная – воздействует синфазно, то есть с одинаковой фазой и в одинаковой полярности на оба проводника. На выходе схемы устанавливается дифференциальный усилитель показан ниже:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/459ccd75-12dc-40d1-ba17-14e5a54ff7ce)

В результате, если полезный сигнал, имеет на двух проводниках потенциал +2 и -2 вольта соответственно, результатом вычисления будет число 4. Помеха же, имеющая потенциал +3 и -3 вольта, то есть, одинаковый на обоих проводниках, будет иметь результирующее значение, равное нулю, как показано ниже. При этом, что ЭДС помехи вырабатывается в обеих сигнальных линиях, это никак не заметно на принимающей стороне. Если передавать цифровой сигнал – нули и единички, они точно так же, без искажений достигали своей цели, невзирая на наличие синфазной помехи. Именно такую методичку передачи сигнала и использует стандарт USB.

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/34edf2d4-c7cd-475b-abe2-386b4a5bd651)

Для передачи логических битов USB использует метод NRZI (non-return-to-zero inverted). Он состоит в том, что логический 1 будет принят, когда сигнал остается на том же уровне, а логический 0 когда сигнал меняется с течением времени. Схема показана ниже 

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/5b514acf-82d9-4c5d-86c5-3de5b43264d2)

### Настройка Virtual COM Port в STM32
Для связи с ПК по USB был использован микроконтроллер stm32f103c8t6 входящий в состав отладочной платы "bluepill".
В среде STM32 CubeMX для организации связи был включен режим USB Device, настройки оставлены по умолчанию.

![Pasted image 20240113171914](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/d5769d7d-5a56-458d-bae2-b9a100c41d51)

Далее в разделе "Middleware and software" USB устройство было настроено для связи с помощью Virtual COM Port. Настройки можно увидеть на рисунке ниже.

![Pasted image 20240113172042](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/7bd4701f-9458-48a7-9f05-077791950b9d)

Важно удостовериться, что в дереве тактирования в поле "To USB" установлено значение 48 МГц для правильной работы шины USB. 

![Pasted image 20240113172342](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/b61e9f83-d838-4eac-a196-a8b120350711)

Также для корректной инициализации всех структур USB необходимо во вкладке "Project manager" установить для линковщика размер кучи 0х1000.

![Pasted image 20240113172832](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/a51edaaa-b8d1-4cb9-9b31-6407a3454bd1)

После генерации кода, в директории `USB_DEVICE\App` появится файл `usb_cdc_if.c`
В нем нас интересует байтовый массив UserRxBufferFS, в который попадают принимаемые через COM порт данные, а также функции:

```c
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len);
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len);
```

Функция CDC_Receive_FS вызывается автоматически при приеме последовательности байт, функция CDC_Transmit_FS инициирует передачу данных по последовательному порту.
Отредактируем функцию CFC_Receive_FS так, чтобы она приняла следующий вид:

```c
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len){
	/* USER CODE BEGIN 6 */
	USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);

	USBD_CDC_ReceivePacket(&hUsbDeviceFS);

	memcpy(&input, UserRxBufferFS, 4);

	CDC_Transmit_FS(&button_state, 1);

	return (USBD_OK);
	/* USER CODE END 6 */
}
```

Функция memcpy в данном случае принимает в качестве аргументов указатель на поле input (переменная типа float), указатель на массив, в котором находятся принятые данные, а также длину копируемых данных - 4 байта. Данная функция копирует принятые данные в поле переменной с плавающей точкой.

Функция CDC_Transmit_FS в данном случае инициализирует отправку байтовой переменной button_state, в которой будет храниться состояние кнопки.

Таким образом, при приеме сообщения из последовательного порта, данные будут преобразовываться в вещественное число и сразу последует ответ в виде сигнала с кнопки.

### Подключение кнопки
Для обеспечение изменяемого возмущения на входе звена, было решено установить кнопку. При нажатии кнопки, состояние входа меняется с 0 на 1.
Для этого кнопка установлена в разрыв пина PC14 и GND микроконтроллера.

![Без имени](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/1020a5fa-0e22-4df0-8bcd-60bd44735cbe)

В среде CubeMX данный пин был сконфигурирован для чтения, а также была включена его подтяжка. Для индикации нажатия также был задействован пин PC13, к которому подключен пользовательский светодиод на отладочной плате. Настройки можно увидеть на рисунке ниже.

![Pasted image 20240113175910](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/73b68988-b93d-4b44-8488-2eb8aad52369)

Для борьбы с дребезгом кнопки был использован программный фильтр, принимающий то значение сигнала, которое превалировало в течение выбранного периода времени (не менее 80%)

### Модель в MATLAB Simulink
Для взаимодействия с микроконтроллером была построена модель колебательного звена, на вход которой подается сигнал с кнопки, а выход звена отправляется на микроконтроллер.
Структурную схему можно увидеть на рисунке ниже

![Pasted image 20240113180912](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/f0582340-cc6d-4835-9c81-153cd4d26bef)

Назначение блоков:
- Serial Configuration - устанавливает настройки последовательного порта, к которому производится подключение
- Serial Receive - принимает данные с выбранного последовательного порта и отправляет их на выход в формате uint8_t
- Cast To Double - преобразует целочисленное значение сигнала с кнопки в вещественное двойной точности. Этого требует блок передаточной функции.
- Transfer Fcn - блок, рассчитывающий состояние записанной в нем передаточной функции в зависимости от входа, и выдающий текущее значение сигнала на выход.
- Cast To Single - преобразует вещественное число двойной точности в число одинарной точности для уменьшения числа передаваемых на микроконтроллер данных.
- Byte Pack - разбивает бинарное представление входящего числа на необходимое количество байт. На выходе с блока получается байтовый массив.
- Serial Send - отправляет данные о сигнале на выходе звена по выбранному последовательному порту.

Параметры симуляции можно увидеть на рисунке ниже

![Pasted image 20240113181854](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/dffdb128-b74b-4f81-8c77-fbd8053b4a97)

### Результаты работы
Результатом работы стало звено в Simulink, отвечающее на сигнал с кнопки, подключенной к микроконтроллеру. Также данные о состоянии звена передаются на микроконтроллер.

![Pasted image 20240113182232](https://github.com/JV4K/Embedded-systems-LB2/assets/65915049/df0cb194-ae0b-478c-ab44-d181ecb62f50)

[Видео с демонстрацией](https://drive.google.com/file/d/1sjTdtu9nMbFM1tPGHMToLFWWme2I0hzE/view?usp=sharing)
